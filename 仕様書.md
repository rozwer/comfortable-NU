## **仕様書：セキュアなGoogleカレンダー自動登録Chrome拡張機能**

### **1. 概要**

本仕様書は、ユーザーのGoogleカレンダーと連携し、指定した予定を安全に追加するChrome拡張機能および、そのバックエンドシステムの要件と実装手順を定義する。

本システムは、ユーザー認証、ドメイン所持確認、API利用回数制限、DDoS攻撃対策といった複数のセキュリティ要件を満たしながら、サーバーレスアーキテクチャによる高いコスト効率とスケーラビリティを実現することを目的とする。

---

### **2. システムアーキテクチャ**

本システムは、クライアントである**Chrome拡張機能**と、**Firebase**および**Google Cloud**で構築されたバックエンドサービス群で構成される。



#### **使用サービス一覧**
* **クライアント**: Chrome拡張機能
* **バックエンド処理**: Cloud Functions for Firebase
* **データベース**: Cloud Firestore
* **ユーザー認証**: Firebase Authentication / Chrome Identity API
* **アプリ認証 (DDoS対策)**: Firebase App Check
* **Webページホスティング**: Firebase Hosting
* **外部連携API**: Google Calendar API
* **認証基盤**: Google Cloud Identity Platform (OAuth 2.0)

---

### **3. 要件定義**

#### **3.1. 機能要件**
* ユーザーは拡張機能のUIから、予定の「日時」と「内容」を入力できる。
* システムは、ユーザーのGoogleカレンダーに指定された日時の予定が既に存在しないか（重複がないか）をチェックする。
* 重複がなければ、システムはユーザーのプライマリカレンダーに新しい予定を追加する。
* 重複がある場合は、その旨をユーザーに通知し、予定の追加は行わない。

#### **3.2. セキュリティ・制限要件**
* **ユーザー認証**: システムの利用には、ユーザー自身のGoogleアカウントによる認証を必須とする。
* **ドメイン所持確認**: 初回利用時、ユーザーは大学のメールアドレス (`ac.jp`) の所持を証明する必要がある。この確認が完了するまで、機能は利用できない。
* **レート制限**: 機能の利用（カレンダーへの追加成功）は、1ユーザーあたり1日1回に制限する。
* **アプリケーション認証**: バックエンドAPIは、正規のChrome拡張機能からのリクエストのみを受け付け、ボットや不正なスクリプトからの直接的なアクセスはすべて拒否する (**Firebase App Check**)。
* **DDoS攻撃対策**: ネットワークレベルのDDoS攻撃に対して、Google Cloudのインフラによる標準的な保護を備える。

#### **3.3. 非機能要件**
* **コスト**: Firebaseの無料利用枠の範囲内で運用可能であること。
* **インフラ**: サーバーのプロビジョニングや管理が不要なサーバーレスアーキテクチャで構築する。

---
---

### **4. 実装ステップ**

#### **フェーズ1：プロジェクト基盤のセットアップ**

1.  **Firebaseプロジェクト作成**: Firebaseコンソールで新規プロジェクトを作成する。
2.  **Blazeプランへ変更**: プロジェクトを従量課金制のBlazeプランにアップグレードする。
3.  **API有効化**: Google Cloudコンソールで「**Google Calendar API**」と「**Firebase App Check API**」を有効化する。
4.  **OAuth同意画面設定**: アプリ名や連絡先などを入力し、OAuth同意画面を構成する。
5.  **OAuthクライアントID作成**: 「Chromeアプリ」種類のOAuth 2.0 クライアントIDを作成し、発行された**クライアントID**を控える。
6.  **App Check設定**: FirebaseコンソールでApp Checkを有効化し、「Chrome拡張機能」をアプリとして登録後、Cloud Functionsへの適用を有効にする。

#### **フェーズ2：`ac.jp`認証Webアプリの構築**

1.  **ローカル環境初期化**: `firebase init`コマンドで`Hosting`, `Functions`, `Firestore`を初期化する。
2.  **認証ページの作成**: `hosting`ディレクトリに、ユーザーが`ac.jp`メールアドレスを入力し、認証をリクエストするためのWebページ（HTML/CSS/JS）を作成する。
3.  **認証ロジックの実装**: 認証リクエストの受付と確認メール送信、およびメール内のリンククリックによる認証完了処理を行うためのCloud Functionsを2つ作成する。

#### **フェーズ3：Chrome拡張機能の実装**

1.  **`manifest.json`の作成**: 拡張機能の定義ファイルを作成する。`permissions`に`identity`を、`oauth2`ブロックにフェーズ1で取得したクライアントIDと必要なスコープを記述する。また、`host_permissions`にデプロイ後のCloud FunctionsのURLを指定する。
2.  **UIの作成 (`popup.html`)**: 日時と内容を入力するフォームを持つHTMLファイルを作成する。
3.  **ロジックの実装 (`popup.js`)**:
    * `chrome.identity.getAuthToken`を使い、ユーザーの認証とOAuthトークンの取得を行う。
    * Firebase App Check SDKを使い、アプリ認証用のApp Checkトークンを取得する。
    * `fetch` APIまたはFirebase SDKを使い、取得した2種類のトークン（OAuth, App Check）と入力データをバックエンドのCloud Functionsへ送信する。
    * バックエンドからの応答（成功、重複エラー、回数制限エラー、未認証エラー等）をハンドリングし、UIに結果を表示するロジックを実装する。

#### **フェーズ4：バックエンドの実装 (Cloud Functions & Firestore)**

1.  **Firestoreデータモデル設計**:
    * **`users`コレクション**: ユーザー情報を格納する。ドキュメントIDはユーザーのGoogle ID (`uid`)とする。
        * `isVerified` (boolean): `ac.jp`認証が完了したか。
        * `lastApiCall` (timestamp): 最後にAPIを正常利用した日時。
2.  **メイン関数の実装 (`index.js`)**:
    * HTTPS Callable Function (`onCall`)として、全てのロジックを内包する単一の関数を作成する。
    * **App Checkの強制**: 関数の定義で`enforceAppCheck: true`オプションを設定し、不正なクライアントからのアクセスを自動的にブロックする。
    * **処理フロー**:
        1.  **認証チェック**: `request.auth`オブジェクトが存在するか確認する（`onCall`では自動）。
        2.  **資格チェック**: Firestoreからユーザーのドキュメントを読み出し、`isVerified`が`true`か確認する。
        3.  **回数制限チェック**: `lastApiCall`の日時と現在時刻を比較し、24時間以内であればエラーを返す。
        4.  **カレンダー重複チェック**: クライアントから渡されたOAuthトークンを使い、Google Calendar API (`events.list`)を呼び出して重複を確認する。
        5.  **カレンダーへ追加**: 重複がなければ、Google Calendar API (`events.insert`)で予定を追加する。
        6.  **タイムスタンプ更新**: 成功した場合、Firestoreの`lastApiCall`を現在時刻で更新する。
        7.  **結果返却**: 処理結果に応じたメッセージをクライアントに返す。

#### **フェーズ5：デプロイと最終化**

1.  **デプロイ**: `firebase deploy`コマンドで、作成したFirestoreルール、Functions、Hostingのすべてをデプロイする。
2.  **設定更新**: デプロイ後に確定したCloud FunctionsのURLを、拡張機能の`manifest.json`に反映させる。
3.  **最終ID登録**: `chrome://extensions`で開発者モードを有効にし、拡張機能を読み込む。表示された**拡張機能ID**をコピーし、Google CloudコンソールのOAuthクライアントID設定に最終的な値として登録する。
4.  **総合テスト**: 拡張機能をリロードし、初回利用時の`ac.jp`認証から、日々のカレンダー登録、各種エラーハンドリングまで、すべてのフローが仕様通りに動作することを確認する。